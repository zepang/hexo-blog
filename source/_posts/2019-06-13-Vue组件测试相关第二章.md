---
title: Vue组件测试相关第二章
img: 'https://placem.at/places?h=140'
date: 2019-06-13 16:55:54
categories: 前端
---
上一章节我大概介绍，Vue组件测试需要了解的基本内容，这一章节我们先来了解一下如何测试Vue组件的输出结果。

## 测试Vue组件的输出结果

接下来说了一下测试Vue组件的输出结果通常会用的测试操作，测试内容以及对应常用的api。

### 测试组件的文本内容

结合 `@vue/test-utils`的text方法写法：

```js
expect(wrapper.text()).toBe('Hello, World!')
```

这里需要注意的是`toBe`，它会严格的检查组件的文本内容是否和期望的完全一致。一旦你要向组件中添加额外的文本，那么这个测试就会中断。通常情况我们都是检查是否包含期望的文本内容，所以建议将`toBe`替换成`toContain`。

### 查找节点

```js
wrapper.find('a').text()
wrapper.findAll('div').length
wrapper.findAll('div').toHaveLength(5)
```

### 测试元素的文本内容

```js
(wrapper.find('a').text()).toBe('Hello, World!')
```

### 测试DOM的属性

```js
expect(wrapper.attributes().href).toBe('http://baidu.com')
```

如果你需要获取DOM元素的内容，你可以使用`.element`这个属性

```js
expect(wrapper.element.style.width).toBe('100%')
```
### 测试组件的输入属性

```js
items.wrappers.forEach((wrapper, i) => {
  expect(wrapper.props().item).toBe(window.items[i])
})
```

需要注意的我们在写测试的时候不需要去写静态样式和静态样式内容的测试，说实在的这些测试基本没有什么意义，如果你想查看静态的样式和内容你只要在调试模式下用浏览器查看就足够了。所以对于组件的输出内容，我们需要写的测试都是以动态生成的内容的测试代码。

关于上边的api这些方面的内容建议大家多看看`@vue/test-utils`的文档，测试中需要用到的方法基本都有提供。接下来我们来看看如何测试组件的方法。

## 测试组件的方法

#### 测试普通函数

通常是通过`wrapper.vm`获取实例直接调用方法来测试组件的方法

```js
test('is hidden when hide is called', () => {
  const wrapper = shallowMount(Popup) 
  wrapper.vm.hide() 
  expect(wrapper.element.style.display).toBe('none') 
})
```

##### jest 间谍函数

```js
jest.spyOn(window, 'clearInterval')
setInterval.mockReturnValue(123)
....
expect(window.clearInterval).toHaveBeenCalledWith(123)
```

spyOn通常用来测试函数是否被调用。除此之外，还有类似的jest.fn(), jest.mock()，不过这三者的应用场景不尽相同。

##### 将公用组件挂载到Vue的实例上

```js
import ProgressBar from './components/ProgressBar'

const bar = new Vue(ProgressBar).$mount()
document.body.append(bar.$el)
Vue.prototype.$bar = bar

new Vue({
  el: '#app',
  render: h => h(App)
})
```

#### mocking code

我们知道，当我们需要使用到Vue实列上的全局方法或者组件的时候，我们通常的做法是在应用的入口文件中添加类似上边的代码。但是当我们需要进行单组件测试的时候，我们需要自己提前将
全局的方法挂载到Vue的实例上。这种做法在`@vue/test-utils`的文档上叫做将**全局属性存根**

```js
import { shallowMount } from '@vue/test-utils'
import Foo from './Foo.vue'

describe('Foo', () => {
  it('renders a div', () => {
    const $route = { path: 'http://www.example-path.com' }
    const wrapper = shallowMount(Foo, {
      mocks: {
        $route
      }
    })
    expect(wrapper.vm.$route.path).toBe($route.path)
  })
})
```


#### 测试异步代码

通常使用async, await方式来等待正确的结果

```js
test('fetches data', async () => { 
  expect.assertions(1) 
  const data = await fetchListData() 
  expect(data).toBe('some data')
})
```

如果遇到不能使用async，await的方式处理逻辑，比如使用promise，在then中才返回结果，那么可以使用` flush-promises` 这个库达到上述效果：

```js
test('awaits promises', async () => {
  expect.assertions(1)
  let hasResolved = false
  Promise.resolve().then(() => {
  hasResolved = true
  })
  await flushPromises()
  expect(hasResolved).toBe(true)
})
```

在使用 `async` `await` 的函数的时候发现jest报 import 语法错误，检查发现是node_modules的Babel包里边用了import，而我之前在jest-config.js中的设置是：

```js
transformIgnorePatterns: ['node_modules']
```

完全忽略node_modules，也就是不会用babel转义任何node_modules中的语法。为了修复这个jest报错，改成下面的配置：

```js
transformIgnorePatterns: ["node_modules/(?!(@babel)/)"]
```

不排除babel包的转义
